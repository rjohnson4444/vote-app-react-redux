var surroundConstructor, hasSetter, removeSetter, removePropertySetters, imutable;
surroundConstructor = require('surround-constructor');
hasSetter = curry$(function(obj, prop){
  return obj.__lookupSetter__(prop) != null;
});
removeSetter = curry$(function(obj, prop){
  return Object.defineProperty(obj, prop, {
    set: void 8
  });
});
removePropertySetters = function(klass){
  var proto;
  proto = klass.prototype;
  return Object.getOwnPropertyNames(proto).filter(hasSetter(proto)).forEach(removeSetter(proto));
};
function makeImutable(obj, arg$){
  var ref$, recursive, ref1$, hidden;
  ref$ = arg$ != null
    ? arg$
    : {}, recursive = (ref1$ = ref$.recursive) != null ? ref1$ : false, hidden = (ref1$ = ref$.hidden) != null ? ref1$ : false;
  if (recursive) {
    makeChildrenImutable(obj, {
      recursive: true,
      hidden: hidden
    });
  }
  obj.__imutable__ = true;
  return Object.freeze(obj);
}
function makeChildrenImutable(obj, arg$){
  var ref$, recursive, ref1$, hidden, propertyNames, this$ = this;
  ref$ = arg$ != null
    ? arg$
    : {}, recursive = (ref1$ = ref$.recursive) != null ? ref1$ : false, hidden = (ref1$ = ref$.hidden) != null ? ref1$ : false;
  propertyNames = (function(){
    switch (false) {
    case !hidden:
      return Object.getOwnPropertyNames(obj);
    default:
      return Object.keys(obj);
    }
  }());
  return propertyNames.forEach(function(it){
    if (typeof obj[it] === 'object') {
      return makeImutable(obj[it], {
        recursive: recursive,
        hidden: hidden
      });
    }
  });
}
imutable = function(option, klass){
  var ref$, recursive, imKlass;
  if (typeof option === 'function') {
    ref$ = [option, ''], klass = ref$[0], option = ref$[1];
  }
  recursive = option === 'recursive';
  if (option === 'strict') {
    removePropertySetters(klass);
  }
  makeImutable(klass.prototype);
  imKlass = surroundConstructor(klass, {
    after: function(){
      return makeImutable(this, {
        recursive: recursive,
        hidden: true
      });
    }
  });
  return makeImutable(imKlass, {
    recursive: recursive
  });
};
module.exports = imutable;
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}